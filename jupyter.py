# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jy-P5FYy1pjODSMW3ubdB0OTtC5S7Qk4
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# https://github.com/weekend37/Backgammon/blob/master/Backgammon.py
"""
Backgammon interface
Run this program to play a game of Backgammon
"""
import numpy as np
import matplotlib.pyplot as plt
import time
import random
import copy

def init_board():
    # initializes the game board

    board = np.zeros(29)
    board[1] = -2
    board[12] = -5
    board[17] = -3
    board[19] = -5
    board[6] = 5
    board[8] = 3
    board[13] = 5
    board[24] = 2

    return board

def roll_dice():
    # rolls the dice

    return np.random.randint(1, 7, 2)

def game_over(board):
    # returns True if the game is over

    return board[27] == 15 or board[28] == -15

def pretty_print(board):
    string = str(np.array2string(board[1:13]) + '\n' +
                 np.array2string(board[24:12:-1]) + '\n' +
                 np.array2string(board[25:29]))
    print("board: \n", string)

def legal_move(board, dice, player):
    # finds legal moves (from, to) for a board and one dice, returns empty list if none

    possible_moves = []

    if player == 1:
        # dead piece, needs to be brought back to life
        if board[25] > 0:
            start_pip = 25 - dice
            if board[start_pip] > -2:
                possible_moves.append(np.array([25, start_pip]))

        # no dead pieces
        else:
            # adding options if player is bearing off
            if sum(board[7:25] > 0) == 0:
                if (board[dice] > 0):
                    possible_moves.append(np.array([dice, 27]))

                elif not game_over(board): # smá fix
                    # everybody's past the dice throw?
                    s = np.max(np.where(board[1:7] > 0)[0] + 1)
                    if s < dice:
                        possible_moves.append(np.array([s, 27]))

            possible_start_pips = np.where(board[0:25] > 0)[0]

            # finding all other legal options
            for s in possible_start_pips:
                end_pip = s-dice
                if end_pip > 0:
                    if board[end_pip] > -2:
                        possible_moves.append(np.array([s, end_pip]))

    elif player == -1:
        # dead piece, needs to be brought back to life
        if board[26] < 0:
            start_pip = dice
            if board[start_pip] < 2:
                possible_moves.append(np.array([26, start_pip]))

        # no dead pieces
        else:
            # adding options if player is bearing off
            if sum(board[1:19] < 0) == 0:
                if (board[25 - dice] < 0):
                    possible_moves.append(np.array([25 - dice, 28]))
                elif not game_over(board): # smá fix
                    # everybody's past the dice throw?
                    s = np.min(np.where(board[19:25] < 0)[0])
                    if (6 - s) < dice:
                        possible_moves.append(np.array([19 + s, 28]))

            # finding all other legal options
            possible_start_pips = np.where(board[0:25] < 0)[0]
            for s in possible_start_pips:
                end_pip = s + dice
                if end_pip < 25:
                    if board[end_pip] < 2:
                        possible_moves.append(np.array([s, end_pip]))

    return possible_moves

def legal_moves(board, dice, player):
    # return all possible pair of legal moves if there exists, empty list otherwise

    moves = []

    # try using the first dice, then the second dice
    possible_first_moves = legal_move(board, dice[0], player)
    for m1 in possible_first_moves:
        temp_board = update_board(board, m1, player)
        possible_second_moves = legal_move(temp_board, dice[1], player)
        for m2 in possible_second_moves:
            moves.append(np.array([m1, m2]))

    if dice[0] != dice[1]:
        # try using the second dice, then the first one
        possible_first_moves = legal_move(board, dice[1], player)
        for m1 in possible_first_moves:
            temp_board = update_board(board, m1, player)
            possible_second_moves = legal_move(temp_board, dice[0], player)
            for m2 in possible_second_moves:
                moves.append(np.array([m1, m2]))

    # if there's no pair of moves available, allow one move:
    if len(moves) == 0:
        # first dice:
        possible_first_moves = legal_move(board, dice[0], player)
        for m in possible_first_moves:
            moves.append(np.array([m]))

        # second dice:
        if dice[0] != dice[1]:
            possible_first_moves = legal_move(board, dice[1], player)
            for m in possible_first_moves:
                moves.append(np.array([m]))

    return moves

def legal_moves2(board, dice, player):
    # Essaye de faire les deux à la fois pour gagner du temps.
    # Situation 1 : aucun pip en prison ne peut sortir
    # Situation 2 : un pip en prison qui peut sortir. On commence par celui-là
    #      puis on appelle legal_move sur l'autre dé.
    # Situation 3 : finale : sum(board[7:25] > 0) == 0
    #       alors on sort ce que l'on peut sortir
    # Situation 4 : pré-finale : sum(board[7:25] > 0) == 1
    #       on regarde si on peut jouer d'abord le seul pip, puis legal_move sur l'autre dé
    # Situation 5 : classique. On calcule les pips qui peuvent jouer le dé 1, puis
    #       ceux qui peuvent jouer le dé 2.
    #       On retourne alors tous les coups produit où ce ne sont pas les mêmes, ou bien
    #       lorsqu'il y a au moins 2 jetons sur le même pip de départ
    #       On rajoute enfin le cas où on déplace le même jeton sur les deux dés.
    moves = []

    if player == 1:
        # dead piece, needs to be brought back to life
        if board[25] >= 1: # S'il y a au moins un pion à sortir
            return(legal_moves(board, dice, player))
        if sum(board[7:25] > 0) <= 1: # finale ou pre finale
            return legal_moves(board,dice,player)
        # On est donc dans la situation classique où il y a au moins deux pions
        # dans la zone de mouvement.
        # first dice:
        possible_first_moves = legal_move(board, dice[0], player)
        possible_second_moves = legal_move(board, dice[1], player)
        # Il y aura d'autres moves si on bouge deux fois le même pion
        # et on enlève du produit cartésien si c'est le même pion au début
        if len(possible_first_moves) == 0:
            return(legal_moves(board, dice, player))
        if len(possible_second_moves) == 0:
            return(legal_moves(board, dice, player))
        # cas ou faire un des deux dés ouvre une possibilité auparavant inexistante pour l'autre dé

        if dice[0] != dice[1]:
            # création du produit cartésien, possible car mouvement commute
            for m1 in possible_first_moves:
                for m2 in possible_second_moves:
                    if m1[0] != m2[0] or board[m1[0]] >= 2:
                        moves.append([m1, m2])
            for m1 in possible_first_moves:
                if board[m1[1]] < 1: # nouvel endroit car sinon mouv déjà créer par legal moves
                    end_pip = m1[1] - dice[1]
                    if end_pip > 0:
                        if board[end_pip] > -2:
                            moves.append([m1, [m1[1], end_pip]])
            for m1 in possible_second_moves:
                if board[m1[1]] < 1:
                    end_pip = m1[1] - dice[0]
                    if end_pip > 0:
                        if board[end_pip] > -2:
                            moves.append([m1, [m1[1], end_pip]])
        # produit parfois quelques résultats équivalents (mais pas redondants)
        # redondant : faire 8 -> 4 puis 6 -> 3 et faire 6 -> 3 puis 8 -> 4
        # equivalent : donne le meme board mais les coups sont différents
        else: # produit cartésien différent (dés: 3, 4. 6 -> 3, 8 -> 4 et 8 -> 4, 6 -> 3 différent, mais pas si dés égaux)
            n = len(possible_first_moves)
            for i in range(n):
                for j in range(i, n): #
                    m1 = possible_first_moves[i]
                    m2 = possible_first_moves[j]
                    if m1[0] != m2[0] or board[m1[0]] >= 2:
                        moves.append([m1, m2])
            for m1 in possible_first_moves:
                if board[m1[1]] < 1:
                    end_pip = m1[1] - dice[1]
                    if end_pip > 0:
                        if board[end_pip] > -2:
                            moves.append([m1, [m1[1], end_pip]])


    if player == -1:
        # dead piece, needs to be brought back to life
        if board[26] <= -1: # S'il y a au moins un pion à sortir
            return(legal_moves(board,dice,player))
        if sum(board[1:19] < 0) <= 1:
            return legal_moves(board,dice,player)
        # On est donc dans la situation classique où il y a au moins deux pions
        # dans la zone de mouvement.
        # first dice:
        possible_first_moves = legal_move(board, dice[0], player)
        possible_second_moves = legal_move(board, dice[1], player)
        # Il y aura d'autres moves si on bouge deux fois le même pion
        # et on enlève du produit cartésien si c'est le même pion au début
        if len(possible_first_moves) == 0:
            return(legal_moves(board, dice, player))
        if len(possible_second_moves) == 0:
            return(legal_moves(board, dice, player))

        if dice[0] != dice[1]:
            for m1 in possible_first_moves:
                for m2 in possible_second_moves:
                    if m1[0] != m2[0] or board[m1[0]] <= -2:
                        moves.append([m1, m2])
            for m1 in possible_first_moves:
                if board[m1[1]] > -1:
                    end_pip = m1[1] + dice[1]
                    if end_pip < 25:
                        if board[end_pip] < 2:
                            moves.append([m1, [m1[1], end_pip]])
            for m1 in possible_second_moves:
                if board[m1[1]] >- 1:
                    end_pip = m1[1] + dice[0]
                    if end_pip < 25:
                        if board[end_pip] <2:
                            moves.append([m1, [m1[1], end_pip]])
        else:
            n = len(possible_first_moves)
            for i in range(n):
                for j in range(i, n):
                    m1 = possible_first_moves[i]
                    m2 = possible_first_moves[j]
                    if m1[0] != m2[0] or board[m1[0]] <= -2:
                        moves.append([m1, m2])
            for m1 in possible_first_moves:
                if board[m1[1]] >- 1:
                    end_pip = m1[1] + dice[1]
                    if end_pip < 25:
                        if board[end_pip] < 2:
                            moves.append([m1, [m1[1], end_pip]])

    return moves

def update_board(board, move, player):
    # updates the board (play a move)

    board_to_update = copy.deepcopy(board)

    startPip = move[0]
    endPip = move[1]

    # moving the dead piece if the move kills a piece
    kill = board_to_update[endPip] == (-1*player)

    if kill:
        board_to_update[endPip] = 0
        jail = 25 + (player == 1)
        board_to_update[jail] = board_to_update[jail] - player

    board_to_update[startPip] = board_to_update[startPip] - 1*player
    board_to_update[endPip] = board_to_update[endPip] + player

    return board_to_update

def winner_gains(winner, board):
    # distribute points to winner according to status of final board.
    if winner == 1:
        points = 1
        #if board[28] == 0:
        #    points = 2
        #    if sum(board[1:13]) < 0:
        #        points = 3
    else:
        points = 0
        #points = -1
        #if board[27] == 0:
        #    points = -2
        #    if sum(board[13:25]) > 0:
        #        points = -3

    return points

def play_a_game(winners, nb_legal_moves = {}):
    # simulate a game with randomized moves

    board = init_board()
    player = 1
    dice_rolls = 0

    while not game_over(board):
        dice = roll_dice()
        while dice_rolls == 0 and dice[0] == dice [1]:
          dice = roll_dice()
        dice_rolls += 1

        # make a move (2 moves if the same number appears on the dice)
        for _ in range(1 + int(dice[0] == dice[1])):
            board_copy = np.copy(board)

            possible_moves = legal_moves2(board_copy, dice, player)
            # pm2 = legal_moves(board_copy, dice, player)
            # if not compare(possible_moves, pm2):
            #     print(f"C'est au coup {dice_rolls}, les des ont donné {dice}\n")
            #     pretty_print(board)
            #     print(possible_moves)
            #     print(pm2)
            #     print("\n\n")

            # Study of the distribution of number of legal moves
            # nb_moves = len(possible_moves)
            # if nb_moves >= 170:
            #     print(dice)
            #     print(player)
            #     pretty_print(board_copy)

            # if nb_moves not in nb_legal_moves.keys():
            #     nb_legal_moves[nb_moves] = 1
            # else:
            #     nb_legal_moves[nb_moves] += 1

            if len(possible_moves) != 0:
                move = random.choice(possible_moves)
                for m in move:
                    board = update_board(board, m, player)

        # players take turns
        player = -player

    # if game_over(board):
    #     print("final move, dice and board:")
    #     print(move)
    #     print(dice)
    #     pretty_print(board)

    # updates of statistics
    winner = -player
    points = winner_gains(winner, board)
    if winner == 1:
        winners["orange"][0] += 1
        if points == 1:
            winners["orange"][1] += 1
        elif points == 2:
            winners["orange"][2] += 1
        else:
            winners["orange"][3] += 1
    else:
        winners["blue"][0] += 1
        if points == -1:
            winners["blue"][1] += 1
        elif points == -2:
            winners["blue"][2] += 1
        else:
            winners["blue"][3] += 1

    return winners, dice_rolls/2, nb_legal_moves

def main():
    games = 1000

    winners = {"orange": [0, 0, 0, 0], "blue": [0, 0, 0, 0]} # Collecting stats of the games
    mean_dice_rolls = 0
    mean_run_time = 0
    nb_legal_moves = {}

    for _ in range(games):
        startTime = time.time()

        winners, dice_rolls, nb_legal_moves = play_a_game(winners, nb_legal_moves)
        mean_dice_rolls += dice_rolls

        runTime = time.time() - startTime
        mean_run_time += runTime

    mean_dice_rolls = mean_dice_rolls/games
    mean_run_time = mean_run_time/games

    # Plotting the distribution of the number of legal moves
    # nb_legal_moves = dict(sorted(nb_legal_moves.items()))
    # max_key = max(nb_legal_moves.keys())
    # completed_dict = {i: nb_legal_moves.get(i, 0) for i in range(max_key + 1)}

    # plt.bar(completed_dict.keys(), completed_dict.values(), color = 'blue')
    # plt.xlabel('Number of legal moves')
    # plt.ylabel('Distribution')
    # plt.title(f'Distribution of the number of legal moves over {games} games (about {mean_dice_rolls*games} turns).')
    # plt.grid(True)
    # plt.show()

    print(f"Out of {games} games between blue and orange, with orange always beginning:\n")
    print(f"Player orange won {winners['orange'][0]} times ({round(100*winners['orange'][0]/games, 2)}%) and won " \
          f"{winners['orange'][1] + winners['orange'][2]*2 + winners['orange'][3]*3} points.")
    print(f"Player blue won {winners['blue'][0]} times ({round(100*winners['blue'][0]/games, 2)}%) and won " \
          f"{winners['blue'][1] + winners['blue'][2]*2 + winners['blue'][3]*3} points.\n")
    print(f"Player orange won {winners['orange'][1]} 1-point plays, {winners['orange'][2]} 2-point plays " \
          f"and {winners['orange'][3]} 3-point plays.")
    print(f"Player blue won {winners['blue'][1]} 1-point plays, {winners['blue'][2]} 2-point plays " \
          f"and {winners['blue'][3]} 3-point plays.\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {round(mean_dice_rolls, 2)} dice rolls.\n")

#main()

import copy
import random
import time

def playout(board, dice, player):
    board_copy = copy.deepcopy(board)
    # pretty_print(board)

    while not game_over(board_copy):
        for _ in range(1 + int(dice[0] == dice[1])):
            moves = legal_moves2(board_copy, dice, player)

            if len(moves) != 0:
                move = random.choice(moves)
                for m in move:
                    board_copy = update_board(board_copy, m, player)

            # print(dice, move, player)
            # pretty_print(board_copy)

        player = -player
        dice = roll_dice()

    score = winner_gains(-player, board_copy)
    return score

def flatMC(board, dice, player, n):
    bestScore = 0
    bestMove = 0
    comparison = {} # study on opening move

    moves = legal_moves2(board, dice, player)
    if len(moves) == 0:
        return []
    elif len(moves) == 1:
        return moves[0]

    for i in range(len(moves)):
        board_copy = copy.deepcopy(board)

        sum = 0
        victory = 0
        for _ in range(n):
            score = playout(board_copy, dice, player)
            # sum = sum + score # study on points rather than victory

            if score > 0:
                victory += 1
                sum += 1

        proba_victory = victory/(n)
        comparison[str(moves[i])] = proba_victory

        if sum > bestScore:
            bestScore = sum
            bestMove = i

    #for move in comparison.keys(): # study on opening move
        #print(f"Move: {move}, proba:{comparison[move]}")
    #values = comparison.values()
    #dif = max(values) - min(values)
    #l = len(values)
    #print(f"dice: {dice}, Diff: {dif}, len: {l}\n")

    return moves[bestMove]

def main2():
    N = 50
    games = 10

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            dice = roll_dice()
            while i == 0 and dice [0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[12] # study on opening move
            #print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = flatMC(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move

            player = -player

            dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                moves = legal_moves(board, dice, player)
                if len(moves) != 0:
                    move_random = random.choice(moves)
                    for m in move_random:
                        board = update_board(board, m, player)
                    print(f"Turn: {i}, best move random: {move_random}\n")
                #else: print(f"Turn: {i}, best move random:  no available move\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime


        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"FlatMC won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"Random won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

#main()

#MaxLegalMoves = 15**4
Table = {}

def add (board_number):
    nplayouts = {}
    nwins = {}
    Table [board_number] = [0, nplayouts, nwins]

def look (board_number):
    return Table.get(board_number, None)

def code(dice, move):
    if len(move) == 2:
        code_move = f"{dice[0]}{dice[1]}{move[0][1]}{move[1][1]}"
    elif len(move) == 3:
        code_move = f"{dice[0]}{dice[1]}{move[0][1]}{move[1][1]}{move[2][1]}"
    elif len(move) == 4:
        code_move = f"{dice[0]}{dice[1]}{move[0][1]}{move[1][1]}{move[2][1]}{move[3][1]}"
    else:
        code_move = f"{dice[0]}{dice[1]}{move[0][1]}"

    return code_move

def playoutAMAF(board, dice, player, played):
    board_copy = copy.deepcopy(board)
    # pretty_print(board)

    while not game_over(board_copy):
        for _ in range(1 + int(dice[0] == dice[1])):
            moves = legal_moves2(board_copy, dice, player)

            if len(moves) != 0:
                move = random.choice(moves)
                code_move = code(dice, move)
                played.append(code_move)
                for m in move:
                    board_copy = update_board(board_copy, m, player)

            # print(dice, move, player)
            # pretty_print(board_copy)

        player = -player
        dice = roll_dice()

    score = winner_gains(-player, board_copy)
    return score

#MaxCodeLegalMoves = (6*26)**4

def addAMAF(board_number):
    nplayouts = {}
    nwins = {}
    amafwins = {}
    amafplayouts = {}
    Table [board_number] = [0, nplayouts, nwins, amafplayouts, amafwins]

def updateAMAF(t, played, res):
    for i in range(len(played)):
        if played[:i].count(played[i]) == 0:
            if played[i] in t[3]:
                t[3][played[i]] += 1
                t[4][played[i]] += res
            else:
                t[3][played[i]] = 1
                t[4][played[i]] = res

def GRAVE (board, dice, player, played, tref, seen_boards):
    if game_over(board):
        score = winner_gains(-player, board)
        return score
    board_number = next((i for i, b in enumerate(seen_boards) if np.array_equal(b, board)), None)
    t = look(board_number)
    if t != None:
        tr = tref
        if t [0] > 50:
            tr = t
        bestValue = 0
        best = 0
        moves = legal_moves2(board, dice, player)
        if len(moves) == 0:
            best = None
        else:
            bestcode = code(dice, moves[0])
            for i in range (0, len (moves)):
                val = 1000000.0
                code_m = code(dice, moves[i])
                if code_m in tr[3]:
                    if tr [3] [code_m] > 0:
                        if i not in t[1]:
                            t[1][i] = 0
                            t[2][i] = 0
                        beta = tr [3][code_m] / (t [1] [i] + tr [3] [code_m] + 1e-5 * t [1] [i] * tr [3] [code_m])
                        Q = 1
                        if t [1] [i] > 0:
                            Q = t [2] [i] / t [1] [i]
                            if player == -1:
                                Q = 1 - Q
                        AMAF = tr [4] [code_m] / tr [3] [code_m]
                        if player == -1:
                            AMAF = 1 - AMAF
                        val = (1.0 - beta) * Q + beta * AMAF
                    if val > bestValue:
                        bestValue = val
                        best = i
                        bestcode = code_m
        if best is not None:
            for m in moves[best]:
                board = update_board(board, m, player)
            played.append(bestcode)
            if not any(np.array_equal(board, b) for b in seen_boards):
                seen_boards.append(board)
        dice = roll_dice()
        player = -player
        res = GRAVE(board, dice, player, played, tr, seen_boards)
        t [0] += 1
        if best is not None:
            if best in t[1]:
                t [1] [best] += 1
                if res < 0:
                    victory = 0
                else:
                    victory = 1
                t [2] [best] += victory
            else:
                t [1] [best] = 1
                if res < 0:
                    victory = 0
                else:
                    victory = 1
                t [2] [best] = victory
            updateAMAF (t, played, res)
        return res
    else:
        addAMAF (board_number)
        return playoutAMAF (board, dice, player, played)

def BestMoveGRAVE (board, dice, player, seen_boards, n):
    global Table
    Table = {}
    board_number = next((i for i, b in enumerate(seen_boards) if np.array_equal(b, board)), None)
    print(board_number)
    addAMAF (board_number)
    for i in range (n):
        root = look (board_number)
        b1 = copy.deepcopy (board)
        res = GRAVE (b1, dice, player, [], root, seen_boards)
    root = look (board_number)
    moves = legal_moves2(board, dice, player)
    if len(moves) == 0:
        return []
    best = moves [0]
    bestValue = root [1] [0]

    for i in range (1, len(moves)):
        if i not in root[1]: root[1][i] =0
        if (root [1] [i] > bestValue):
            bestValue = root [1] [i]
            best = moves [i]
    return best


def main3():
    N = 100
    games = 50

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            seen_boards = []
            dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[11] # study on opening move
            print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMoveGRAVE(board, dice, player, seen_boards, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move grave: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break

            #inp = input() # study on opening move
            player = -player

            #dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                moves = legal_moves(board, dice, player)
                if len(moves) != 0:
                    move_random = random.choice(moves)
                    for m in move_random:
                        board = update_board(board, m, player)
                    print(f"Turn: {i}, best move random: {move_random}\n")
                else: print(f"Turn: {i}, best move random:  no available move\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime

        winner = -player
        print(winner)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"GRAVE won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"Random won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

#main()

def main4():
    N = 50
    games = 10

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)

        player = 1

        i = 0
        while not game_over(board):
            seen_boards = []
            dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[11] # study on opening move
            print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMoveGRAVE(board, dice, player, seen_boards, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move grave: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break

            #inp = input() # study on opening move
            player = -player

            #dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = flatMC(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                    print(f"Turn: {i}, best move flat: {move_MC}\n")
                else: print(f"Turn: {i}, best move flat:  no available move\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime

        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"GRAVE won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"flat won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main4()

def RAVE (board, dice, player, played, seen_boards):
    if game_over(board):
        score = winner_gains(-player, board)
        return score
    board_number = next((i for i, b in enumerate(seen_boards) if np.array_equal(b, board)), None)
    t = look(board_number)
    if t != None:
        bestValue = 0
        best = 0
        moves = legal_moves2(board, dice, player)
        if len(moves) == 0:
            best = None
        elif len(moves) == 1:
            best = 0
            bestcode = code(dice, moves[0])
        else:
            bestcode = code(dice, moves[0])
            for i in range (0, len (moves)):
                val = 1000000.0
                code_m = code(dice, moves[i])
                if code_m in t[3]:
                    if t [3] [code_m] > 0:
                        if i not in t[1]:
                            t[1][i] = 0
                            t[2][i] = 0
                        beta = t [3][code_m] / (t [1] [i] + t [3] [code_m] + 1e-5 * t [1] [i] * t [3] [code_m])
                        Q = 1
                        if t [1] [i] > 0:
                            Q = t [2] [i] / t [1] [i]
                            if player == -1:
                                Q = 1 - Q
                        AMAF = t [4] [code_m] / t [3] [code_m]
                        if player == -1:
                            AMAF = 1 - AMAF
                        val = (1.0 - beta) * Q + beta * AMAF
                    if val > bestValue:
                        bestValue = val
                        best = i
                        bestcode = code_m
        if best is not None:
            for m in moves[best]:
                board = update_board(board, m, player)
            played.append(bestcode)
            if not any(np.array_equal(board, b) for b in seen_boards):
                seen_boards.append(board)
        dice = roll_dice()
        player = -player
        res = RAVE(board, dice, player, played, seen_boards)
        t [0] += 1
        if best is not None:
            if best in t[1]:
                t [1] [best] += 1
                if res < 0:
                    victory = 0
                else:
                    victory = 1
                t [2] [best] += victory
            else:
                t [1] [best] = 1
                if res < 0:
                    victory = 0
                else:
                    victory = 1
                t [2] [best] = victory
            updateAMAF (t, played, res)
        return res
    else:
        addAMAF (board_number)
        return playoutAMAF (board, dice, player, played)

def BestMoveRAVE (board, dice, player, seen_boards, n):
    global Table
    Table = {}
    board_number = next((i for i, b in enumerate(seen_boards) if np.array_equal(b, board)), None)
    addAMAF (board_number)
    for i in range (n):
        b1 = copy.deepcopy (board)
        res = RAVE (b1, dice, player, [], seen_boards)
    root = look (board_number)
    moves = legal_moves2(board, dice, player)
    if len(moves) == 0:
        return []
    best = moves [0]
    bestValue = root [1] [0]
    for i in range (1, len(moves)):
        if i not in root[1]: root[1][i] =0
        if (root [1] [i] > bestValue):
            bestValue = root [1] [i]
            best = moves [i]
    return best


def main5():
    N = 1000
    games = 1

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)
        seen_boards = []
        seen_board_grave = []
        player = 1

        i = 0
        while not game_over(board):
            dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[11] # study on opening move
            print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMoveRAVE(board, dice, player, seen_boards, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break

            #inp = input() # study on opening move
            player = -player

            #dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMoveGRAVE(board, dice, player, seen_board_grave, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime

        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"RAVE won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"Random won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

#main()

from math import sqrt

def ucb (board, dice, player, N, c = 0.4):
    moves = legal_moves2(board, dice, player)
    if len(moves) == 0:
        return []
    # bestScore = 0
    bestMove = 0
    w = [0] * len(moves)
    n = [0] * len(moves)
    print(moves)
    pretty_print(board)
    for i in range(len(moves)):
        print(moves[i])
        b = copy.deepcopy(board)
        for m in moves[i]:
            b = update_board(b, m, player)
        pretty_print(b)
        player = -player
        dice = roll_dice()
        pretty_print(b)
        print(len(b))
        r = playout(b, dice, player)
        print(r)
        if player == -1:
            r = 1 - r
        w[i] += r
        n[i] += 1
    for _ in range(N):
        result = [w[i]/n[i] + c*sqrt(np.log(sum(n))/n[i]) for i in range(len(moves))]
        print(result)
        bestMove = np.argmax(result)
        print("YAAAAS")
        b = copy.deepcopy(board)
        for m in moves[bestMove]:
            b = update_board(b, m, player)
        player = -player
        dice = roll_dice()
        print(dice)
        pretty_print(b)
        r = playout(b, dice, player)
        if player == -1:
            r = 1 - r
        w[bestMove] += r
        n[bestMove] += 1
    return moves [np.argmax(n)]


def main6():
    N = 50
    games = 1
    c = 0.4

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        #pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            dice = roll_dice()
            while i == 0 and dice[0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[11] # study on opening move
            print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = ucb(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move
            player = -player

            #dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                moves = legal_moves(board, dice, player)
                if len(moves) != 0:
                    move_random = random.choice(moves)
                    for m in move_random:
                        board = update_board(board, m, player)
                    print(f"Turn: {i}, best move random: {move_random}\n")
                else: print(f"Turn: {i}, best move random:  no available move\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime

        winner = -player
        print(winner)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"ucb won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"Random won {winners['random'][0]} times ({round(100*winners['random'][0]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

#main()

from math import log

def uct(board, dice, player, seen_boards, c = 0.4):
    if game_over(board):
        return winner_gains(-player, board)
    board_number = next((i for i, b in enumerate(seen_boards) if np.array_equal(b, board)), None)
    t = look(board_number)
    if t is not None:
        bestValue = 0
        bestMove = 0
        moves = legal_moves2(board, dice, player)

        if len(moves) == 0:
            bestMove = None
        for m in range(len(moves)):
            val = 1000000.0
            if m not in t[1]:
                t[1][m] = 0
                t[2][m] = 0
            n = t[0]
            ni = t[1][m]
            wi = t[2][m]
            if ni > 0:
                Q = wi/ni
                if player == -1:
                    Q = 1 - Q
                val = Q + c*sqrt(log(n)/ni)
            if val > bestValue:
                bestValue = val
                bestMove = m
        if bestMove is not None:
            for m in moves[bestMove]:
                board = update_board(board, m, player)
            if not any(np.array_equal(board, b) for b in seen_boards):
                seen_boards.append(board)
        player = -player
        dice = roll_dice()
        res = uct(board, dice, player, seen_boards)
        t[0] += 1
        if bestMove is not None:
            t[1][bestMove] += 1
            t[2][bestMove] += res
    else:
        add(board_number)
        res = playout(board, dice, player)

    return res

def bestMoveUct(board, dice, player, N, seen_boards):
    global Table
    Table = {}
    for i in range(N):
        b1 = copy.deepcopy(board)
        res = uct(b1, dice, player, seen_boards)
    board_number = next((i for i, b in enumerate(seen_boards) if np.array_equal(b, board)), None)
    t = look(board_number)
    moves = legal_moves2(board, dice, player)
    if len(moves) == 0:
        return []
    best = moves[0]
    bestValue = t[1][0]
    for i in range(1, len(moves)):
        if (t[1][i] > bestValue):
            bestValue = t[1][i]
            best = moves[i]
    return best


def main7():
    N = 50
    games = 10
    c = 0.4

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        #pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            seen_boards = []
            dice = roll_dice()
            while i == 0 and dice[0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[11] # study on opening move
            print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMoveGRAVE(board, dice, player, seen_boards, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move grave: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move
            player = -player

            seen_boards = []

            #dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = bestMoveUct(board, dice, player, N, seen_boards)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move uct: {move_MC}\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime

        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"grave won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"uct won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main7()

# 50 : uct gagne les 3, 200 : uct gagne 2 sur 3

from math import sqrt
def main7():
    N = 500
    games = 10
    c = 0.4

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        #pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            seen_boards = []
            dice = roll_dice()
            while i == 0 and dice[0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[11] # study on opening move
            print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMoveGRAVE(board, dice, player, seen_boards, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move grave: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move
            player = -player

            seen_boards = []

            #dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = bestMoveUct(board, dice, player, N, seen_boards)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move uct: {move_MC}\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime

        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"grave won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"uct won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main7()

def main8():
    N = 100
    games = 50
    c = 0.4

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        #pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            seen_boards = []
            dice = roll_dice()
            while i == 0 and dice[0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[11] # study on opening move
            print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                moves = legal_moves(board, dice, player)
                if len(moves) != 0:
                    move_random = random.choice(moves)
                    for m in move_random:
                        board = update_board(board, m, player)
                    print(f"Turn: {i}, best move random: {move_random}\n")
                #else: print(f"Turn: {i}, best move random:  no available move\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move
            player = -player

            #dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = bestMoveUct(board, dice, player, N, seen_boards)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move uct: {move_MC}\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime

        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"random won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"uct won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main8()

def main9():
    N = 50
    games = 10
    c = 0.4

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        #pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            seen_boards = []
            dice = roll_dice()
            while i == 0 and dice[0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[11] # study on opening move
            print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = flatMC(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                    print(f"Turn: {i}, best move flat: {move_MC}\n")
                else: print(f"Turn: {i}, best move flat:  no available move\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move
            player = -player

            #dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = bestMoveUct(board, dice, player, N, seen_boards)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move uct: {move_MC}\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime

        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"flat won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"uct won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main9()

40*log2(40)

from math import sqrt, log2

def sequentialHalving(board, dice, player, budget, seen_boards):
    global Table
    Table = {}
    board_number = next((i for i, b in enumerate(seen_boards) if np.array_equal(b, board)), None)
    add(board_number)
    moves = legal_moves2(board, dice, player)
    if len(moves) == 0:
        return []
    total = len(moves)
    nplayouts = {}
    nwins = {}
    while len(moves) > 1:
        for move in moves:
            code_move = code(dice, move)
            for i in range(int(budget//len(moves)*np.log2(total))):
                s = copy.deepcopy(board)
                for m in move:
                    s = update_board(s, m, player)
                res = uct(s, dice, player, seen_boards)
                if code_move not in nplayouts:
                    nplayouts[code_move] = 0
                    nwins[code_move] = 0
                nplayouts[code_move] += 1
                if player == 1:
                    nwins[code_move] += res
                else:
                    nwins[code_move] += 1.0 - res
        moves = bestHalf(board, dice, player, moves, nwins, nplayouts)
    return moves[0]

def bestHalf(board, dice, player, moves, nwins, nplayouts):
    half = []
    notused = {}
    for i in range(int(np.ceil(len(moves)/2))):
        best = -1.0
        bestMove = moves[0]
        for move in moves:
            code_move = code(dice, move)
            if code_move not in notused:
                notused[code_move] = True
            if notused[code_move]:
                if not code_move in nwins:
                    mu = 0
                else:
                    mu = nwins[code_move] / nplayouts[code_move]
                if mu > best:
                    best = mu
                    bestMove = move
        code_best = code(dice, bestMove)
        notused[code_best] = False
        half.append(bestMove)
    return half

# to check
def BestMoveHalving (board, dice, player, n, seen_boards):
    global Table
    Table = {}
    board_number = next((i for i, b in enumerate(seen_boards) if np.array_equal(b, board)), None)
    add(board_number)
    for i in range (n):
        b1 = copy.deepcopy (board)
        res = sequentialHalving (b1, dice, player, 10, seen_boards)
    root = look (board_number)
    moves = legal_moves2(board, dice, player)
    if len(moves) == 0:
        return []
    best = moves [0]
    bestValue = root [1] [0]
    for i in range (1, len(moves)):
        if (root [1] [i] > bestValue):
            bestValue = root [1] [i]
            best = moves [i]
    return best


def main():
    N = 50
    games = 1

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            seen_boards = []
            dice = roll_dice()
            while i == 0 and dice [0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[12] # study on opening move
            #print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMoveHalving(board, dice, player, N, seen_boards)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move

            player = -player

            dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                moves = legal_moves(board, dice, player)
                if len(moves) != 0:
                    move_random = random.choice(moves)
                    for m in move_random:
                        board = update_board(board, m, player)
                    print(f"Turn: {i}, best move random: {move_random}\n")
                else: print(f"Turn: {i}, best move random:  no available move\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime


        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"FlatMC won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"Random won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main()

import copy
import random
import math

class Policy (object):
    def __init__ (self):
        self.dict = {}

    def get (self, code):
        if not code in self.dict:
            self.dict[code] = {}
        w = self.dict[code]
        return w

    def put (self, code, w):
        self.dict [code] = w

seen_boards = {}
Table = {}

def getboard_code(board):
    strboard = str(board)
    if not strboard in seen_boards:
        seen_boards[str(board)] = len(seen_boards)
    board_number = seen_boards[str(board)]
    return board_number


def playoutPPA (board, dice, player, policy :Policy):
    board_copy = copy.deepcopy(board)
    p = []
    d = []
    while not game_over(board_copy):
        for _ in range(1 + dice[0] == dice[1]):
            code_board = getboard_code(board_copy)
            policy_board = policy.get(code_board)
            l = legal_moves2(board_copy, dice, player)
            if len(l) != 0:
                z = 0
                for i in range (len (l)):
                    code_m = code(dice, l[i])
                    if not code_m in policy_board:
                        policy_board[code_m] = 0
                    z = z + math.exp(policy_board[code_m])
                stop = random.random () * z
                move = 0
                z = 0
                while True:
                    code_m = code(dice, l[move])
                    z = z + math.exp(policy_board[code_m])
                    if z >= stop:
                        break
                    move = move + 1
                for m in l[move]:
                    board_copy = update_board(board_copy, m, player)
                p.append(l[move])
                d.append(dice)

        dice = roll_dice()
        player = -player
    return winner_gains(-player, board_copy), p, d

def adapt (s, winner, board, player, p, d, policy):
    board_copy = copy.deepcopy(board)
    polp = copy.deepcopy (policy)
    alpha = 0.32
    for a in range(len(p)):
    #while not game_over(s):
        for _ in range(1 + d[a][0] == d[a][1]):
            l = legal_moves2(s, d[a], player)
            move = p[a]
            code_board = getboard_code(board_copy)
            policy_board = policy.get(code_board)
            polp_board = polp.get(code_board)
            if player == winner:
                z = 0
                for i in range (len (l)):
                    code_m = code(d[a], l[i])
                    if not code_m in policy_board:
                        policy_board[code_m] = 0
                    z = z + math.exp (policy_board[code_m])
                code_m = code(d[a], move)
                if not code_m in polp_board:
                    polp_board[code_m] = 0
                polp.put (code_m, polp_board[code_m] + alpha)
                for i in range (len (l)):
                    code_m = code(d[a], l[i])
                    proba = math.exp (policy_board[code_m]) / z
                    if not code_m in polp_board:
                        polp_board[code_m] = 0
                    polp.put (code_m, polp_board[code_m] - alpha * proba)
            for m in move:
                board_copy = update_board(board_copy, m, player)
        player = -player
    return polp

def PPAF(board, dice, player, p, d, policy):
    if game_over(board):
        return winner_gains(-player, board), p, d
    t = look (getboard_code(board))
    if t != None:
        bestValue = -1000000.0
        best = 0
        moves = legal_moves2(board, dice, player)
        if len(moves) == 0:
            best = None
        for i in range (0, len (moves)):
            val = 1000000.0
            if i not in t[1]:
                t[1][i] = 0
                t[2][i] = 0
            if t [1] [i] > 0:
                Q = t [2] [i] / t [1] [i]
                if player == -1:
                    Q = 1 - Q
                val = Q + 0.4 * math.sqrt (math.log (t [0]) / t [1] [i])
            if val > bestValue:
                bestValue = val
                best = i
        if best is not None:
            for m in moves[best]:
                board = update_board(board, m, player)
        dice = roll_dice()
        player = -player
        res, p, d = PPAF (board, dice, player, p, d, policy)
        t [0] += 1
        if best is not None:
            if best not in t[1]:
                t[1][best] = 0
                t[2][best] = 0
            t [1] [best] += 1
            t [2] [best] += res
            p.append(moves[best])
            d.append(dice)
        return res, p, d
    else:
        add (getboard_code(board))
        return playoutPPA (board, dice, player, policy)

def BestMovePPAF (board, dice, player, n):
    global Table
    Table = {}
    global seen_boards
    seen_boards = {}
    policy = Policy()
    p = []
    d = []
    for i in range (n):
        b1 = copy.deepcopy (board)
        res, p, d = PPAF (b1, dice, player, p, d, policy)
        b2 = copy.deepcopy (board)
        if res == 1:
            policy = adapt (b2, 1, b1, player, p, d, policy)
        else:
            policy = adapt (b2, -1, b1, player, p, d, policy)
    code_board = getboard_code(board)
    t = look (code_board)
    moves = legal_moves2(board, dice, player)
    if len(moves) == 0:
        return []
    best = moves [0]
    bestValue = t [1] [0]
    for i in range (1, len(moves)):
        if (t [1] [i] > bestValue):
            bestValue = t [1] [i]
            best = moves [i]
    return best


def main():
    N = 50
    games = 10

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            dice = roll_dice()
            while i == 0 and dice [0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[12] # study on opening move
            #print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMovePPAF(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move

            player = -player

            dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                moves = legal_moves(board, dice, player)
                if len(moves) != 0:
                    move_random = random.choice(moves)
                    for m in move_random:
                        board = update_board(board, m, player)
                    print(f"Turn: {i}, best move random: {move_random}\n")
                else: print(f"Turn: {i}, best move random:  no available move\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime


        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"PPA won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"Random won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

#main()

def main():
    N = 50
    games = 10

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            dice = roll_dice()
            while i == 0 and dice [0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[12] # study on opening move
            #print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMovePPAF(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move

            player = -player

            seen_boardsss = []

            dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMoveGRAVE(board, dice, player, seen_boardsss, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move grave: {move_MC}\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime


        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"PPA won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"grave won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main()

def main():
    N = 50
    games = 10

    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            dice = roll_dice()
            while i == 0 and dice [0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[12] # study on opening move
            #print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMovePPAF(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move

            player = -player

            seen_boardsss = []

            dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = bestMoveUct(board, dice, player, N, seen_boardsss)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move uct: {move_MC}\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime


        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"PPA won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"uct won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main()

def main():
    N = 50
    games = 5
    winners = {"flatMC": [0, 0, 0, 0], "random": [0, 0, 0, 0]}
    mean_dice_rolls = 0
    mean_run_time = 0

    for _ in range(games):
        startTime = time.time()

        board = init_board()
        pretty_print(board)
        player = 1

        i = 0
        while not game_over(board):
            dice = roll_dice()
            while i == 0 and dice [0] == dice[1]:
                dice = roll_dice()
            mean_dice_rolls += 1
            beginning_dices = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 3], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6], [4, 5], [4, 6], [5, 6]]
            #dice = beginning_dices[12] # study on opening move
            #print(dice)

            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = BestMovePPAF(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)
                if game_over(board):
                    break

            if game_over(board):
                player = -player
                break
            #inp = input() # study on opening move

            player = -player

            dice = roll_dice()
            for _ in range(1 + int(dice[0] == dice[1])):
                move_MC = flatMC(board, dice, player, N)
                if len(move_MC) != 0:
                    for m in move_MC:
                        board = update_board(board, m, player)
                print(f"Turn: {i}, best move MC: {move_MC}\n")
                pretty_print(board)

            player = -player
            i += 1

        runTime = time.time() - startTime
        mean_run_time += runTime


        winner = -player
        print(winner)
        pretty_print(board)
        points = winner_gains(winner, board)
        if winner == 1:
            winners["flatMC"][0] += 1
            if points == 1:
                winners["flatMC"][1] += 1
            elif points == 2:
                winners["flatMC"][2] += 1
            else:
                winners["flatMC"][3] += 1
        else:
            winners["random"][0] += 1
            if points == -1:
                winners["random"][1] += 1
            elif points == -2:
                winners["random"][2] += 1
            else:
                winners["random"][3] += 1

    mean_dice_rolls = mean_dice_rolls//games
    mean_run_time = mean_run_time/games

    print(f"Out of {games} games between flatMC and random (N = {N}):\n")
    print(f"PPA won {winners['flatMC'][0]} times ({round(100*winners['flatMC'][0]/games, 2)}%).")
    print(f"flat won {winners['random'][3]} times ({round(100*winners['random'][3]/games, 2)}%).\n")
    print(f"On average, a game last {round(mean_run_time, 3)}s and is played in {mean_dice_rolls} dice rolls.\n")

main()

def main2():
    N = 10000

    startTime = time.time()

    player = 1
    dice = [3, 5]
    good_move = [[8, 3], [6, 3]]
    bad_move = [[], []]


    seen_boardsss = []

        board = init_board()
        print(dice)

        #move_MC = flatMC(board, dice, player, N)
        move_MC = BestMoveGRAVE(board, dice, player, seen_boardsss, N)
        #move_MC = bestMoveUct(board, dice, player, N, seen_boards)
        #move_MC = BestMovePPAF(board, dice, player, N)
        for m in move_MC:
            board = update_board(board, m, player)
        print(f"Turn: 1, best move flat: {move_MC}\n")
        pretty_print(board)

        runTime = time.time() - startTime
        mean_run_time += runTime

    mean_run_time = mean_run_time/games
    print(f"On average, a move last {round(mean_run_time, 3)}s.\n")

main2()